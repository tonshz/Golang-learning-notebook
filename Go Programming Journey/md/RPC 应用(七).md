# Go 语言编程之旅(三)：RPC 应用(七) 

## 十二、实现自定义的 protoc 插件

在开发 gRPC +`Protobuf` 的相关服务时，用到了许多与 `protoc `相关的插件来实现各种功能。

| 插件名称                  | 对应的命令           |
| ------------------------- | -------------------- |
| `protoc-gen-go`           | `--go_out`           |
| `protoc-gen-grpc-gateway` | `--grpc-gateway_out` |
| `protoc-gen-swagger`      | `--swagger_out`      |

并非所有插件都是由 `gRPC`或是`Protobuf`官方人员开发的，开发人员可以定制化开发一个新的`protoc`插件。

### 1. 插件的内部逻辑

通常来说，在实现自定义 `protoc`插件之前，需要分析既有的插件，看看它是怎么做的。首先先来看官方提供的`protoc-gen-go`插件的内部逻辑。

#### a. protoc-gen-gogo/main.go

```go
package main

import (
	"github.com/gogo/protobuf/vanity/command"
)

func main() {
    // Read() => Generate() => Write()
	command.Write(command.Generate(command.Read()))
}
```

#### b. vanity/command/command.go

```go
package command

import (
   "fmt"
   "go/format"
   "io/ioutil"
   "os"
   "strings"

   _ "github.com/gogo/protobuf/plugin/compare"
   _ "github.com/gogo/protobuf/plugin/defaultcheck"
   _ "github.com/gogo/protobuf/plugin/description"
   _ "github.com/gogo/protobuf/plugin/embedcheck"
   _ "github.com/gogo/protobuf/plugin/enumstringer"
   _ "github.com/gogo/protobuf/plugin/equal"
   _ "github.com/gogo/protobuf/plugin/face"
   _ "github.com/gogo/protobuf/plugin/gostring"
   _ "github.com/gogo/protobuf/plugin/marshalto"
   _ "github.com/gogo/protobuf/plugin/oneofcheck"
   _ "github.com/gogo/protobuf/plugin/populate"
   _ "github.com/gogo/protobuf/plugin/size"
   _ "github.com/gogo/protobuf/plugin/stringer"
   "github.com/gogo/protobuf/plugin/testgen"
   _ "github.com/gogo/protobuf/plugin/union"
   _ "github.com/gogo/protobuf/plugin/unmarshal"
   "github.com/gogo/protobuf/proto"
   "github.com/gogo/protobuf/protoc-gen-gogo/generator"
   _ "github.com/gogo/protobuf/protoc-gen-gogo/grpc"
   plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
)

// No.1
func Read() *plugin.CodeGeneratorRequest {
   // 1.创建默认的代码生成器
   g := generator.New()
    
   // 2.从标准输出中读取所需的 CodeGeneratorRequest 信息
   data, err := ioutil.ReadAll(os.Stdin)
   if err != nil {
      g.Error(err, "reading input")
   }

   //3.序列化所读取的 CodeGeneratorRequest
   if err := proto.Unmarshal(data, g.Request); err != nil {
      g.Error(err, "parsing input proto")
   }

   // 4.检查待生成文件的源文件数量，若数量为 0 则不需要生成
   if len(g.Request.FileToGenerate) == 0 {
      g.Fail("no files to generate")
   }
   return g.Request
}

// filenameSuffix replaces the .pb.go at the end of each filename.
func GeneratePlugin(req *plugin.CodeGeneratorRequest, p generator.Plugin, filenameSuffix string) *plugin.CodeGeneratorResponse {
   g := generator.New()
   g.Request = req
   if len(g.Request.FileToGenerate) == 0 {
      g.Fail("no files to generate")
   }

   g.CommandLineParameters(g.Request.GetParameter())

   g.WrapTypes()
   g.SetPackageNames()
   g.BuildTypeNameMap()
   g.GeneratePlugin(p)

   for i := 0; i < len(g.Response.File); i++ {
      g.Response.File[i].Name = proto.String(
         strings.Replace(*g.Response.File[i].Name, ".pb.go", filenameSuffix, -1),
      )
   }
   if err := goformat(g.Response); err != nil {
      g.Error(err)
   }
   return g.Response
}

func goformat(resp *plugin.CodeGeneratorResponse) error {
   for i := 0; i < len(resp.File); i++ {
      formatted, err := format.Source([]byte(resp.File[i].GetContent()))
      if err != nil {
         return fmt.Errorf("go format error: %v", err)
      }
      fmts := string(formatted)
      resp.File[i].Content = &fmts
   }
   return nil
}

// No.2
func Generate(req *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
   // Begin by allocating a generator. The request and response structures are stored there
   // so we can do error handling easily - the response structure contains the field to
   // report failure.
   g := generator.New()
   g.Request = req

   // 5.将从标准输出中所读取到的 CodeGeneratorRequest 传递给 protoc 的代码生成器
   g.CommandLineParameters(g.Request.GetParameter())

   // Create a wrapped version of the Descriptors and EnumDescriptors that
   // point to the file that defines them.
   // 6.封装到 Generator 中的文件引用对象中
   g.WrapTypes()

   // 7.设置包名
   g.SetPackageNames()
    
   // 8.将类型名称映射为对象
   g.BuildTypeNameMap()

   // 9.生成所有的源文件
   g.GenerateAllFiles()

   if err := goformat(g.Response); err != nil {
      g.Error(err)
   }

   testReq := proto.Clone(req).(*plugin.CodeGeneratorRequest)

   testResp := GeneratePlugin(testReq, testgen.NewPlugin(), "pb_test.go")

   for i := 0; i < len(testResp.File); i++ {
      if strings.Contains(*testResp.File[i].Content, `//These tests are generated by github.com/gogo/protobuf/plugin/testgen`) {
         g.Response.File = append(g.Response.File, testResp.File[i])
      }
   }

   return g.Response
}


// No.3
func Write(resp *plugin.CodeGeneratorResponse) {
   g := generator.New()
   // Send back the results.
   // 10.将序列化后的 CodeGeneratorRequest 输出到标准输出
   data, err := proto.Marshal(resp)
   if err != nil {
      g.Error(err, "failed to marshal output proto")
   }
   _, err = os.Stdout.Write(data)
   if err != nil {
      g.Error(err, "failed to write output proto")
   }
}
```

从上述代码中可以看出，此处没有自定义插件的相关逻辑，在`grpc.go`文件中，即如下初始化代码。

```go
_ "github.com/gogo/protobuf/protoc-gen-gogo/grpc"
```

#### c. grpc.go

```go
...

func init() {
   generator.RegisterPlugin(new(grpc))
}

// grpc is an implementation of the Go protocol buffer compiler's
// plugin architecture.  It generates bindings for gRPC support.
type grpc struct {
   gen *generator.Generator
}

// Name returns the name of this plugin, "grpc".
func (g *grpc) Name() string {
   return "grpc"
}

...

// Init initializes the plugin.
func (g *grpc) Init(gen *generator.Generator) {
   g.gen = gen
}

...

// Generate generates code for the services in the given file.
func (g *grpc) Generate(file *generator.FileDescriptor) {
   if len(file.FileDescriptorProto.Service) == 0 {
      return
   }

   contextPkg = string(g.gen.AddImport(contextPkgPath))
   grpcPkg = string(g.gen.AddImport(grpcPkgPath))

   g.P("// Reference imports to suppress errors if they are not otherwise used.")
   g.P("var _ ", contextPkg, ".Context")
   g.P("var _ ", grpcPkg, ".ClientConn")
   g.P()

   // Assert version compatibility.
   g.P("// This is a compile-time assertion to ensure that this generated file")
   g.P("// is compatible with the grpc package it is being compiled against.")
   g.P("const _ = ", grpcPkg, ".SupportPackageIsVersion", generatedCodeVersion)
   g.P()

   for i, service := range file.FileDescriptorProto.Service {
      g.generateService(file, service, i)
   }
}

// GenerateImports generates the import declaration for this file.
func (g *grpc) GenerateImports(file *generator.FileDescriptor) {}

...
```

实际上，它将自定义的 grpc 插件注册到了 generator 中，这意味着只需将公共的 main 方法中的内容拷贝一份然后就可以根据实际需要实现自定义的 `protoc`插件了。

### 2. generator.Plugin 接口

在查看 grpc 插件时，会发现它实现了很多方法，只需重点关注 `generator.Plugin`的相关接口即可。

```go
type Plugin interface {
	// Name identifies the plugin.
	Name() string
	// Init is called once after data structures are built but before
	// code generation begins.
	Init(g *Generator)
	// Generate produces the code generated by the plugin for this file,
	// except for the imports, by calling the generator's methods P, In, and Out.
	Generate(file *FileDescriptor)
	// GenerateImports produces the import declarations for this file.
	// It is called after Generate.
	GenerateImports(file *FileDescriptor)
}
```

在实现自定义插件时，只需满足该`Plugin`接口的定义，就可以无缝的接入 protoc，此接口设计 4 个方法。

+ `Name`：插件的名称
+ `Init`：插件初始化动作
+ `Generate`：生成文件所需的具体代码
+ `GenerateImports`：生成文件所需的具体导入声明。

简单来说，只要包含了公共的 main 方法并实现了`generator.Plugin`接口的4个方法，就可以在`protoc`中使用自定义插件。由此可见，grpc 插件是根据`Plugin`接口的主题流程来流转的。

### 3. FileDescriptor 属性

既然是针对 `proto`文件来生成对应的 Go 代码，那么在生成文件时必然需要很多可用的细腻些，即在`proto`文件中定义的信息。查看所使用的`tag.proto`文件。

```go
syntax = "proto3"; // 1

package proto; // 2

import "proto/common.proto"; // 3
import "google/api/annotations.proto";

service TagService { // 4
    rpc GetTagList (GetTagListRequest) returns (GetTagListResponse) {
        option (google.api.http) = {
            get: "/api/v1/tags" // 5
        };
    };
}

message GetTagListRequest { // 6
    string name = 1;
    uint32 state = 2;
}

message Tag {
    int64 id = 1;
    string name = 2;
    uint32 state = 3;
}

message GetTagListResponse {
    repeated Tag list = 1;
    Pager pager = 2;
}
```

可以看到在一个普通的`proto`文件中，至少包含了6大属性。

+ proto 文件的语法版本，一般为`proto3`或`proto2`
+ 包（package）名称
+ 引入的多个依赖包
+ 多个 RPC 服务（service）的定义
+ 多个 RPC 方法（rpc method）和对应入参、出参的消息体的定义
+ 其他多个消息体的定义

在根据 proto 文件生成对应代码时是需要用到这些信息的，否则无法进行具体的生成。Plugin 接口方法中提供的`FileDescriptor`属性就包含了这些信息。

```go
// FileDescriptor describes an protocol buffer descriptor file (.proto).
// It includes slices of all the messages and enums defined within it.
// Those slices are constructed by WrapTypes.
type FileDescriptor struct {
   *descriptor.FileDescriptorProto
   desc []*Descriptor          // All the messages defined in this file.
   enum []*EnumDescriptor      // All the enums defined in this file.
   ext  []*ExtensionDescriptor // All the top-level extensions defined in this file.
   imp  []*ImportedDescriptor  // All types defined in files publicly imported by this file.

   // Comments, stored as a map of path (comma-separated integers) to the comment.
   comments map[string]*descriptor.SourceCodeInfo_Location

   // The full list of symbols that are exported,
   // as a map from the exported object to its symbols.
   // This is used for supporting public imports.
   exported map[Object][]symbol

   importPath  GoImportPath  // Import path of this file's package.
   packageName GoPackageName // Name of this file's Go package.

   proto3 bool // whether to generate proto3 code for this file
}
```

`FileDescriptor`属性所包含的信息非常多，主要分为文件的描述信息、消息体的定义、枚举的定义、顶级扩展的定义、公开导入的文件中的所有类型的定义、注释、导出的符号的完整列表（作为从导出的对象到其符号的映射）、该文件包的导入路径、该文件的 Go 软件包的名称，以及是否以此文件生成 `proto3`代码。

其包含的属性层层嵌套，展示一些与本次生成 proto 文件相关的属性，以便后续的开发和使用。

#### a. proto 文件的描述（FileDescriptor）

| 字段名           | 类型                      | 含义                                        |
| ---------------- | ------------------------- | ------------------------------------------- |
| Name             | *string                   | proto 文件名                                |
| Package          | *string                   | proto 文件的包名称                          |
| Dependency       | []string                  | proto 文件中引用（import）的依赖包列表      |
| PublicDependency | []int32                   | Dependency 引用的依赖包列表中的索引         |
| WeakDependency   | []int32                   | 仅适用于 Google 内部迁移，不需要了解        |
| MessageType      | []*DescriptorProto        | 所有消息体（message）类型的定义             |
| EnumType         | []EnumDescriptorProto     | 所有枚举（enum）类型的定义                  |
| Service          | []*ServiceDescriptorProto | 所有服务（service）类型的定义               |
| Extension        | []*FiledDescriptorProto   | 所有扩展信息的定义                          |
| Options          | *FileOptions              | 文件选项                                    |
| SourceCodeInfo   | *SourceCodeInfo           | 源代码的相关信息                            |
| Syntax           | *string                   | proto 文件的语法版本，值为 proto2 或 proto3 |

#### b. Service 定义的描述（ServiceDescriptorProto）

| 字段名  | 类型                     | 含义                   |
| ------- | ------------------------ | ---------------------- |
| Name    | *string                  | 服务（service）名      |
| Method  | []*MethodDescriptorProto | 方法（rpc method）列表 |
| Options | *ServiceOptions          | 服务选项               |

#### c. Service 中 Method 定义的描述（MethodDescriptorProto）

| 字段名          | 类型           | 含义                                 |
| --------------- | -------------- | ------------------------------------ |
| Name            | *string        | 方法名称                             |
| InputType       | *string        | 方法的入参类型                       |
| OutputType      | *string        | 方法的出参类型                       |
| Options         | *MethodOptions | 方法选项                             |
| ClientStreaming | *bool          | 标识客户端是否流式传输多个客户端信息 |
| ServerStreaming | *bool          | 标识服务端是否流式传输多个服务信息   |

### 4. 实现一个简单的自定义插件

创建一个新的项目目录 `protoc-gen-go-tour`，对项目进行初始化，并新建对应的文件，代码如下。

```bash
$ go mod init protoc-gen-go-tour
```

最终目录结构如下。

![image-20220528165445360](https://raw.githubusercontent.com/tonshz/test/master/img/202205281654904.png)

下载所需的依赖模块，在项目根目录下执行：

```bash
$ go get -u github.com/golang/protobuf@v1.3.3
```

#### a. 公共 generator

打开`main.go`文件，写入固定的公共`generator`逻辑。

```go
package main

import (
	"io/ioutil"
	"os"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/generator"
)

func main() {
	// Begin by allocating a generator. The request and response structures are stored there
	// so we can do error handling easily - the response structure contains the field to
	// report failure.
	g := generator.New()

	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		g.Error(err, "reading input")
	}

	if err := proto.Unmarshal(data, g.Request); err != nil {
		g.Error(err, "parsing input proto")
	}

	if len(g.Request.FileToGenerate) == 0 {
		g.Fail("no files to generate")
	}

	g.CommandLineParameters(g.Request.GetParameter())

	// Create a wrapped version of the Descriptors and EnumDescriptors that
	// point to the file that defines them.
	g.WrapTypes()

	g.SetPackageNames()
	g.BuildTypeNameMap()

	g.GenerateAllFiles()

	// Send back the results.
	data, err = proto.Marshal(g.Response)
	if err != nil {
		g.Error(err, "failed to marshal output proto")
	}
	_, err = os.Stdout.Write(data)
	if err != nil {
		g.Error(err, "failed to write output proto")
	}
}
```

#### b. 实现 tour 插件

在编写完 generator 的启动代码后，新建`tour.go`文件，写入自定义插件的代码。

```GO
package tour

import "github.com/golang/protobuf/protoc-gen-go/generator"

func init() {
	generator.RegisterPlugin(new(tour))
}

type tour struct {
	gen *generator.Generator
}

func (g *tour) Name() string {
	return "tour"
}

func (g *tour) Init(gen *generator.Generator) {
	g.gen = gen
}

func (g *tour) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	} 
}

func (g *tour) GenerateImports(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
}
```

再在与`main.go`同级的`link_tour.go`文件中写入初始化代码。

```go
import _ "protoc-gen-go-tour/tour"
```

#### c. 验证

在编写玩插件后，是不能直接使用这个插件的，而是需要对其进行编译，然后将编译好的二进制文件移到对应的 bin 目录下，执行如下命令。

```bash
$ go build .
$ mv ./protoc-gen-go-tour.exe $HOME/go/bin # 此处命令在 WIn10 下执行
```

将`tag.proto`文件拷贝一份命名为`tour.proto`，在`ch03`的根目录下执行如下命令。

```bash
$ protoc -I C:\Users\zyc\protoc\include -I C:\Users\zyc\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.14.5\third_party\googleapis -I . --go-tour_out=plugins=tour:. ./proto/tour.proto
```

在上述命令中，新增的命令主要是`--go-tour_out=plugins=tour`，`--go-tour_out`会告诉 protoc 编译器去查找并使用名为`protoc-gen-tour`的插件，而`plugins=tour`则指定使用`protoc-gen-tour`插件中的 tour 子插件（允许在插件中自定义多个子插件）。

#### d. 源码分析

生成完毕后，即可在`proto`目录下看到新生成的`tour.pb.go`文件。

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/tour.proto

package proto

import (
   fmt "fmt"
   proto "github.com/golang/protobuf/proto"
   _ "google.golang.org/genproto/googleapis/api/annotations"
   math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetTagListRequest struct {
   ...
}

func (m *GetTagListRequest) Reset()         { *m = GetTagListRequest{} }
func (m *GetTagListRequest) String() string { return proto.CompactTextString(m) }
func (*GetTagListRequest) ProtoMessage()    {}
func (*GetTagListRequest) Descriptor() ([]byte, []int) {
   return fileDescriptor_1b8a0da1d14bccfa, []int{0}
}

func (m *GetTagListRequest) XXX_Unmarshal(b []byte) error {
   return xxx_messageInfo_GetTagListRequest.Unmarshal(m, b)
}
func (m *GetTagListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
   return xxx_messageInfo_GetTagListRequest.Marshal(b, m, deterministic)
}
func (m *GetTagListRequest) XXX_Merge(src proto.Message) {
   xxx_messageInfo_GetTagListRequest.Merge(m, src)
}
func (m *GetTagListRequest) XXX_Size() int {
   return xxx_messageInfo_GetTagListRequest.Size(m)
}
func (m *GetTagListRequest) XXX_DiscardUnknown() {
   xxx_messageInfo_GetTagListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTagListRequest proto.InternalMessageInfo

func (m *GetTagListRequest) GetName() string {
   ...
}

func (m *GetTagListRequest) GetState() uint32 {
   ...
}

type Tag struct {
   ...
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
   return fileDescriptor_1b8a0da1d14bccfa, []int{1}
}

func (m *Tag) XXX_Unmarshal(b []byte) error {
   return xxx_messageInfo_Tag.Unmarshal(m, b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
   return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
}
func (m *Tag) XXX_Merge(src proto.Message) {
   xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
   return xxx_messageInfo_Tag.Size(m)
}
func (m *Tag) XXX_DiscardUnknown() {
   xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetId() int64 {
   ...
}

func (m *Tag) GetName() string {
   ...
}

func (m *Tag) GetState() uint32 {
   ...
}

type GetTagListResponse struct {
   ...
}

func (m *GetTagListResponse) Reset()         { *m = GetTagListResponse{} }
func (m *GetTagListResponse) String() string { return proto.CompactTextString(m) }
func (*GetTagListResponse) ProtoMessage()    {}
func (*GetTagListResponse) Descriptor() ([]byte, []int) {
   return fileDescriptor_1b8a0da1d14bccfa, []int{2}
}

func (m *GetTagListResponse) XXX_Unmarshal(b []byte) error {
   return xxx_messageInfo_GetTagListResponse.Unmarshal(m, b)
}
func (m *GetTagListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
   return xxx_messageInfo_GetTagListResponse.Marshal(b, m, deterministic)
}
func (m *GetTagListResponse) XXX_Merge(src proto.Message) {
   xxx_messageInfo_GetTagListResponse.Merge(m, src)
}
func (m *GetTagListResponse) XXX_Size() int {
   return xxx_messageInfo_GetTagListResponse.Size(m)
}
func (m *GetTagListResponse) XXX_DiscardUnknown() {
   xxx_messageInfo_GetTagListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTagListResponse proto.InternalMessageInfo

func (m *GetTagListResponse) GetList() []*Tag {
   ...
}

func (m *GetTagListResponse) GetPager() *Pager {
   ...
}

func init() {
   ...
}

func init() { proto.RegisterFile("proto/tour.proto", fileDescriptor_1b8a0da1d14bccfa) }

var fileDescriptor_1b8a0da1d14bccfa = []byte{
   ...
}
```

从上述代码中可以发现，即使没有编写任何新代码，没有输出任何新内容，只是实现了`generator.Plugin`接口中定义的方法，tour 插件也会按规范生成代码。

对`tag.pb.go`文件和`tour.pb.go`文件进行对比，可以发现后者生成的代码没有像前者一样生成 gRPC 相关的方法。`tour.pb.go`文件生成的代码都是针对`Protobuf`，即只生成了 proto 文件（`tour.proto`）和消息体（message）定义、配套方法。

`tour.pb.go`文件中的这些基础 IDL 方法均来源于`protoc-gen-go`插件。`generator`生成器直接使用的是`protoc-gen-go`插件，而`protoc-gen-go`插件的真正本体时 `Protobuf`这个 IDL 生成器。因此指定了`plugins=grpc`，所有会有 gRPC 相关的代码，即在将子插件更换为 tour 后，便只剩默认的与 `Protobuf`相关的 Go 代码的生成功能了。

### 5. 实现定制化的 gRPC 自定义插件

在本章的项目中，至少有两种情况是需要自定义插件的。第一种是基于 gRPC 插件实现一些定制化功能，第二种是基于 proto 文件生成一些扩展性的代码和功能（如在社区中很常见的`protoc-gen-grpc-gateway`和`protoc-gen-swagger`）。

本节基于官方 protoc 的 gRPC 插件实现一个最简单的定制化需求。

#### a. 确认需求

在业务开发过程中，有时候会有多租户的概念，即根据租户标识的不同，获取其对应的租户实例信息和数据。比如，根据租户标识，判定当前部署的环境（如灰度环境或私有环境），以便进行更多的精确调度。因此必须在调用中传播租户标识。

#### b. 解决方法

解决这个问题方法之一就是开发自定义插件，在调用 gRPC Client 时，就要求必须传入租户标识，并且可以在内部进行入参校验和节点发现。此方案能够较好的解决这个问题，并且对开发人员的直接侵入性较小。

#### c. 实现 tour 插件

首先拷贝一份官方的 gRPC 插件中的代码，原因有两个：第一，官方的 gRPC 插件中的代码是不可导出（无法外部引用）的；第二，需要对源代码进行较大的修改。

#####  拷贝插件模板

将`protoc-gen-go/grpc/grpc.go`中的代码完整的复制到项目`tour`目录下的`tour.go`文件中，并将其对应所有的标识修改为 tour。

```go
package tour
...
type tour struct {
   gen *generator.Generator
}

func (g *tour) Name() string {
	return "tour"
}
...
```

主要将包名称修改为 tour，原本的 grpc 结构体及其方法也都调整为了 tour，并且修改了插件的名称，即 Name 方法返回的结果。

##### 分析插件模板

在修改官方的 gRPC 插件之前，必须了解其原有逻辑，下面先来看看最核心的`Generate`方法。

```go
// Generate generates code for the services in the given file.
func (g *tour) Generate(file *generator.FileDescriptor) {
   if len(file.FileDescriptorProto.Service) == 0 {
      return
   }

   contextPkg = string(g.gen.AddImport(contextPkgPath))
   grpcPkg = string(g.gen.AddImport(grpcPkgPath))

   g.P("// Reference imports to suppress errors if they are not otherwise used.")
   g.P("var _ ", contextPkg, ".Context")
   g.P("var _ ", grpcPkg, ".ClientConnInterface")
   g.P()

   // Assert version compatibility.
   g.P("// This is a compile-time assertion to ensure that this generated file")
   g.P("// is compatible with the grpc package it is being compiled against.")
   g.P("const _ = ", grpcPkg, ".SupportPackageIsVersion", generatedCodeVersion)
   g.P()

   for i, service := range file.FileDescriptorProto.Service {
      g.generateService(file, service, i)
   }
}
```

从上述代码中可以看出，使用次数最多的时 P 方法，P 方法时插件中最常用的方法之一，其作用是将传入的参数打印到所需生成的文件输出上，这是一个相对原子的方法，并不会做过多的事情。

从逻辑上看，该方法主要是对 proto 文件的引入和版本信息进行了输出和定义，然后将最重要的服务（service）逻辑，通过`FileDescriptorProto.Service`（标识所有服务类型的定义）循环调用`generateService`方法进行转换和输出。

`generateService`为主要的生成处理方法，其处理 gRPC Client 生成的方法名为 `generateClientMethod`。

```go
func (g *tour) generateClientMethod(servName, fullServName, serviceDescVar string, method *pb.MethodDescriptorProto, descExpr string) {
   sname := fmt.Sprintf("/%s/%s", fullServName, method.GetName())
   methName := generator.CamelCase(method.GetName())
   inType := g.typeName(method.GetInputType())
   outType := g.typeName(method.GetOutputType())

   if method.GetOptions().GetDeprecated() {
      g.P(deprecationComment)
   }
   g.P("func (c *", unexport(servName), "Client) ", g.generateClientSignature(servName, method), "{")
   if !method.GetServerStreaming() && !method.GetClientStreaming() {
      g.P("out := new(", outType, ")")
      // TODO: Pass descExpr to Invoke.
      g.P(`err := c.cc.Invoke(ctx, "`, sname, `", in, out, opts...)`)
      g.P("if err != nil { return nil, err }")
      g.P("return out, nil")
      g.P("}")
      g.P()
      return
   }
   // Stream auxiliary types and methods： 流辅助类型和方法
   ...
}
```

在分析代码前，可以结合生成后的代码进行观察。

```go
func (c *tagServiceClient) GetTagList(ctx context.Context, in *GetTagListRequest, opts ...grpc.CallOption) (*GetTagListResponse, error) {
   out := new(GetTagListResponse)
   err := c.cc.Invoke(ctx, "/proto.TagService/GetTagList", in, out, opts...)
   if err != nil {
      return nil, err
   }
   return out, nil
}
```

实际上，通过对生成代码和生成后的代码进行对比，可以快速的知道各行代码都做了那些事情。

##### 二次开发

需要做的是对 gRPC Client 方法进行租户标识（orgcode）的获取和判断。若不存在，则直接返回响应的错误信息。因此需要编写获取和设置租户标识值的方法，编写判定租户标识值是否正确的方法，在`tour.go`文件中新增代码。

```go
// 需要在 pb.go 文件中新增获取和设置租户标识值的方法。下为模板代码
/*
   type orgCodeKey struct{}

   func (c *tagServiceClient) WithOrgCode(ctx context.Context, orgCode string) context.Context {
      return context.WithValue(ctx, orgCodeKey{}, orgCode)
   }

   func (c *tagServiceClient) OrgCode(ctx context.Context) string {
      return ctx.Value(orgCodeKey{}).(string)
   }
*/
func (g *tour) generateOrgCodeMethod() {
   g.P("type orgCodeKey struct{}")
   g.P()
   g.P("func (c *tagServiceClient) WithOrgCode(ctx context.Context, orgCode string) context.Context {")
   g.P("return context.WithValue(ctx, orgCodeKey{}, orgCode)")
   g.P("}")
   g.P()
   g.P("func (c *tagServiceClient) OrgCode(ctx context.Context) string {")
   g.P("return ctx.Value(orgCodeKey{}).(string)")
   g.P("}")
}
```

在上述代码中，声明了获取租户标识值得获取和设置方法，在生成具体的 gRPC Client 方法前，需要将`generateOrgCodeMethod`方法的调用添加到主流程中，并且将`WithOrgCode`的定义加入`Client interface`中，以便调用。

```go
// generateService generates all the code for the named service.
func (g *tour) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
   ...
   for i, method := range service.Method {
      g.gen.PrintComments(fmt.Sprintf("%s,2,%d", path, i)) // 2 means method in a service.
      if method.GetOptions().GetDeprecated() {
         g.P("//")
         g.P(deprecationComment)
      }
      g.P(g.generateClientSignature(servName, method))
   }
   // 第一处：新增的 WithOrgCode 定义
   g.P("WithOrgCode(ctx context.Context, orgCode string) context.Context")
   g.P("}")
   g.P()

   // Client structure.
   g.P("type ", unexport(servName), "Client struct {")
   g.P("cc ", grpcPkg, ".ClientConnInterface")
   g.P("}")
   g.P()

   // NewClient factory.
   if deprecated {
      g.P(deprecationComment)
   }
   g.P("func New", servName, "Client (cc ", grpcPkg, ".ClientConnInterface) ", servName, "Client {")
   g.P("return &", unexport(servName), "Client{cc}")
   g.P("}")
   g.P()

   // 第二处：新增 OrgCode 定义
   g.generateOrgCodeMethod()
   ...
}
```

在完成了所需方法的声明和调用后，对`generateClientMethod`方法进行修改。

```go
func (g *tour) generateClientMethod(servName, fullServName, serviceDescVar string, method *pb.MethodDescriptorProto, descExpr string) {
   ...
   if !method.GetServerStreaming() && !method.GetClientStreaming() {
      // 添加租户逻辑
      g.P("orgCode, ok := c.OrgCode(ctx)")
      g.P(`if !ok || orgCode == "" {`)
      g.P(`return nil, errors.New("请调用 WithOrgCode 方法设置租户标识")`)
      g.P("}")
      // =======
      g.P("out := new(", outType, ")")
      // TODO: Pass descExpr to Invoke.
      g.P(`err := c.cc.Invoke(ctx, "`, sname, `", in, out, opts...)`)
      g.P("if err != nil { return nil, err }")
      g.P("return out, nil")
      g.P("}")
      g.P()
      return
   }
}
```

在生成 gRPC Client 方法时，调用了声明的对应方法，并新增了对租户标识的获取和判断，若出现不存在或值为空的情况（也可针对实际业务场景自行定制），则直接返回错误。

因为在返回错误时需要调用 errors 的标准库，而在原先的生成文件中并没有引用该标准库，因此需要在 `tour.go`中声明`errorsPkgPath`，并且在`Generate`方法中进行调用。

```go
...
const (
   contextPkgPath = "context"
   errorPkgPath   = "errors"
   grpcPkgPath    = "google.golang.org/grpc"
   codePkgPath    = "google.golang.org/grpc/codes"
   statusPkgPath  = "google.golang.org/grpc/status"
)

...
// Generate generates code for the services in the given file.
func (g *tour) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}

	// 新增 errors 标准库的引入
	_ = g.gen.AddImport(errorPkgPath)
	contextPkg = string(g.gen.AddImport(contextPkgPath))
	grpcPkg = string(g.gen.AddImport(grpcPkgPath))

	...
}
```

##### 验证生成

回到`protoc-gen-go-tour`项目的根目录，重新编译和移动，执行如下命令：

````bash
$ go build . 
#需要先删除目录下的文件，不然会报错 mv : 当文件已存在时，无法创建该文件。
$ mv ./protoc-gen-go-tour.exe $HOME/go/bin
````

在`ch03`目录下重新对`tag.proto`文件进行生成。

```bash
$ protoc -I C:\Users\zyc\protoc\include -I C:\Users\zyc\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.14.5\third_party\googleapis -I . --go-tour_out=plugins=tour:. ./proto/tour.proto
```

再次查看`tour.pb.go`文件。

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/tour.proto

package proto

import (
   context "context"
   // 1.导入 errors 标准库
   errors "errors"
   ...
)

...
// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TagServiceClient interface {
   GetTagList(ctx context.Context, in *GetTagListRequest, opts ...grpc.CallOption) (*GetTagListResponse, error)
    // 2.新增 WithOrgCode() 定义
   WithOrgCode(ctx context.Context, orgCode string) context.Context
}

type tagServiceClient struct {
   cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
   return &tagServiceClient{cc}
}

// 3.新增 OrgCode 定义
type orgCodeKey struct{}

// 4.设置租户标识
func (c *tagServiceClient) WithOrgCode(ctx context.Context, orgCode string) context.Context {
   return context.WithValue(ctx, orgCodeKey{}, orgCode)
}

// 5.获取租户标识
func (c *tagServiceClient) OrgCode(ctx context.Context) string {
   return ctx.Value(orgCodeKey{}).(string)
}
func (c *tagServiceClient) GetTagList(ctx context.Context, in *GetTagListRequest, opts ...grpc.CallOption) (*GetTagListResponse, error) {
   // 6.新增对租户标识的获取和判断
   orgCode, ok := c.OrgCode(ctx)
   if !ok || orgCode == "" {
      return nil, errors.New("请调用 WithOrgCode 方法设置租户标识")
   }
   
   out := new(GetTagListResponse)
   err := c.cc.Invoke(ctx, "/proto.TagService/GetTagList", in, out, opts...)
   if err != nil {
      return nil, err
   }
   return out, nil
}

...
```

从代码中可以看出，在生成的代码中包含了所需的获取和设置租户标识的方法，并且在 gRPC Client 的方法定义和接口声明中也包含了预定义的方法。

##### 验证功能

重新运行 `tag-service`服务，调用客户端，在不进行任何设置的情况下，可以看到如下报错：

```bash
$ go run client.go
tagServiceClient.GetTagList err: 请调用 WithOrgCode 方法设置租户标识
```

此时在`client.go`文件中调用`WithOrgCode`方法进行设置即可。

```go
// 初始化指定 RPC Proto Service 的客户端实例对象
tagServiceClient := pb.NewTagServiceClient(clientConn)
newCtx := tagServiceClient.WithOrgCode(ctx, "Go 语言学习")
// 发起指定 RPC 方法的调用
resp, _ := tagServiceClient.GetTagList(newCtx, &pb.GetTagListRequest{Name: "Go"})
```

如果是通过`grpc-gateway`所映射的 HTTP 接口进行访问也会受到影响。

```json
{
    "error": "请调用 WithOrgCode 方法设置租户标识",
    "code": 2,
    "message": "请调用 WithOrgCode 方法设置租户标识"
}
```

如果希望`grpc-gateway`也能访问，那么需要调整上下文的键，将`grpc-gateway`提供的 Header（`grpc-metadata-*`）转换成 metedata，再进行设置并访问即可。

## 十三、对 gRPC 接口进行版本管理

一般来说，项目会随着时间和需求不断的迭代发展和变更，原本的 gRPC 接口也会出现或大或小的改动，改动需要兼容先前的客户端，需要更好的管理 gRPC 接口版本。

### 1. 接口变更

一般在迭代过程中，最常见的接口 IDL（Protobuf）变更有以下几种：

+ 新增 service 和 rpc 方法
+ 新增 message 中的字段
+ 删除 message 中的字段
+ 修改 message 中的字段类型

这几种变更操作中，有些是可兼容性修改，有些是破坏性修改。

### 2. 可兼容性修改

+ 新增新的 service
+ 在原有的 service 中新增新的 RPC 方法
+ 在原有的请求 message 中新增新的字段
+ 在原有的响应 message 中新增新的字段

### 3. 破坏性修改

+ 修改原有的字段数据类型：修改原有的字段类型会使协议出现重大变更，即在客户端和新服务端交互过程中会出现反序列化报错，影响使用。
+ 修改原有的字段标识位：字段标识位是用来标识其在 Protobuf Payload 中的位置，一旦发生改变，就会出现找不到或者错位的情况。
+ 修改原有的字段名：不会产生直接影响，字段名仅仅在生成的代码中使用，因此不会给 Protobuf 生成的二进制数据带来什么影响。但是，不管在服务端还是在客户端，应用代码都会用到这个字段，但字段名发生改变时，一旦重新编译 Protobuf，就会导致应用无法正常提供服务。
+ 修改 message 原有的命名：不会产生直接影响，因为 message 的命名变更并不会导致协议出现重大变更，但是如果客户端升级了所使用的 Protobuf，那么 message 的命名变更将导致应用代码报错。
+ 删除 service 或 RPC 方法：会造成直接影响。
+ 删除原有的字段：会造成直接影响，

### 4. 设计 gRPC 接口

在变更 gRPC 接口时，要尽可能不影响现有的客户端。因为一旦影响了现有的客户端，则需要通知所有客户端提前进行测试，在同步服务端的更新和发布，这是一件很麻烦的事情。

遇到非常大的接口出参和入参变动，则往往会选择两种方式：一是编写新的 RPC 方法，而是在原有接口内对入参或出参进行转换，然后再内部将流量导向新的 RPC 方法。

### 5. 版本号管理

当进行大版本变更时，应尽可能让两者完全隔离，即不出现版本内互通的情况。

```protobuf
syntax = "proto3";

package proto.v1;

import "proto/common.proto";
import "google/api/annotations.proto";

service TagService {
	rpc GetTagList (GetTagListRequest) returns (GetTagListReply) {
		option (google.api.http) = {
			get: "/api/v1/tags"
		};
	}
}
```

可以在 package 上指定版本号，格式为`proto.v1.TagService`或`proto.v2.TagService`。假设存在 HTTP 路由，则可以将大版本号定义在路由中，格式为`/api/v1/tag`或`/api/v1/tag`。

也可以通过 Header 继续传播，但在 gRPC 下 ，这种模式并不够显性化，并且可能需要进行额外的特殊处理，需要根据实际应用场景进行探讨。

## 十四、常见问题讨论

### 1. Q&A

#### a. 当调用 grpc.Dial 时会连接服务端吗？

会，并且是异步连接的，连接状态为 Connecting（正在连接）状态，如果设置了`grpc.WithBlock`选项，就会阻塞等待（等待到达 Ready）。==**需要注意的是，当未设置`grpc.WithBlock`时，上下文超时控制将不会生效。**==

#### b. 再调用 ClientConn 时不执行 Close 语句会导致泄露吗？

有可能会。除非客户端不是常驻进程，即在应用结束时会被动的回收资源。如果是常驻进程，同时没有执行 Close 语句，则有可能会泄露。

#### c. 如果不做超时控制，会出现什么问题？

短时间内不会出现问题，但是会不断泄露，直至服务无法正常运行。当自身服务逐渐出现问题时，其会影响上下游的服务调用，因此默认对上下文进行超时控制非常重要。

#### d. 频繁创建 ClientConn 有问题吗？

![image-20220528203426200](https://raw.githubusercontent.com/tonshz/test/master/img/202205282055485.png)

但应用场景存在高频次同时生成/调用 ClientConn 时，会导致系统的文件句柄占用过多，需要调整代码。 

#### e. 客户端请求失败后会默认重试吗？

会不断的进行重试，直至上下文取消。一般采用 `backoff` 算法，默认的最大重试时间间隔时 120s。

#### f. 在 Kubernetes 中，gRPC 负载均衡有问题吗？

gRPC 的 RPC 协议是基于 HTTP/2 标准实现的，HTTP/2 的一大特性是，它不像 HTTP/1.1 在每次发出请求时都会重新建立一个新连接，而是会复用原有的连接。

当使用 k8s Service 做负载均衡时，会导致 `kube-proxy` 只有在连接建立时才会做负载均衡，而在这之后的同一个客户端的每一次 RPC 请求都会复用原有的连接，也就是说，实际上后续的每一次 RPC 强求都会被送到同一个服务端去处理，最终导致负载不均衡。

#### g. 用什么微服务框架？

在完整的微服务框架选型上，需要根据实际情况自行处理。

### 2. 小结

+ 客户端请求若使用 `grpc.Dial`方法，则默认是一异步建立连接，连接状态为 Connecting。
+ 客户端请求若需要同步建立连接，则调用`WithBlock`方法，连接状态 Ready。
+ 在特定场景下，如果不对`grpc.ClientConn`进行调控，则会导致文件句柄超出系统限制，影响正常使用。
+ 若内部调用完毕后，`grpc.ClientConn`不关闭连接，则有可能会导致`goroutine`和 `Memory`等出现问题。
+ 任何内/外调用如果不进行超时控制，都会导致泄露和客户端不断重试，最终导致上下游服务出现连环问题，非常危险。
+ 当选择 gRPC 负载均衡模式时，需要谨慎，确定其在那一层进行负载，若直接使用 Kubernetes Service 且不做调整，则很容易出现问题，导致负载不均衡。
+ 完整的微服务框架需要根据企业实际情况进行选型，需根据具体情况具体讨论。

-----------------------------

## 参考

+ [参考文章](https://golang2.eddycjy.com/)

+ [GitHub代码](https://github.com/go-programming-tour-book)

